# 锁

-----------

## TODO

1. [ ] 原来锁需要整合一下
2. [ ] 锁的释放过程
3. [x] Innodb事务实现原理
4. [ ] mysql优化
5. [X] 死锁处理
6. [ ] 数据迁移
7. [ ] 题外话,REDIS 事务实现原理

## 拥塞
  拥塞超时,InnoDB会报异常,InnoDB存储引擎默认不回滚超时引发的错误异常,其实大部分不会对异常进行回滚,需要用户COMMIT还是ROLLBACK

## 锁问题
    1. 脏读
       一个事务读到另一个事务未提交的数据
    2. 不可重复读(幻读)
       读到已经提交数据,InnoDB使用Next-Key lock避免不可重复读
    3. 丢失更新
      可以避免丢失但是可能存在逻辑错误,可以考虑使用select...for update(排他锁)

## 死锁

  * 超时机制,可能会产生大量undolog
  * 等待图 两种信息:锁的信息链表,事务等待链表
    非递归深度优先算法,每个事务请求锁发现等待时会主动判断是否存在回路,若有,InnoDB回滚undo量最小事务
  * 死锁概率 比较低,主要受 事务数量,事务操作数据数量,操作数据集合大小

## 锁升级
   InnoDB不存在锁升级,不是根据每个记录产生行锁,而是根据每个事务访问的每个页进行事务管理,采用位图方式,锁单个记录还是多个记录,开销都是一样的